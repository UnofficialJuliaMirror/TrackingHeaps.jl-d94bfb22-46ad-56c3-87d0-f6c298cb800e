<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TrackingHeaps · TrackingHeaps.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TrackingHeaps.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>TrackingHeaps</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>TrackingHeaps</a></li></ul><a class="edit-page" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>TrackingHeaps</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="TrackingHeaps-1" href="#TrackingHeaps-1">TrackingHeaps</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.TrackingHeaps" href="#TrackingHeaps.TrackingHeaps"><code>TrackingHeaps.TrackingHeaps</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>TrackingHeap is a heap with a tracking system for the stored values.</p><p>Inserting a value into a TrackingHeap returns a tracker for the value. The tracker can be used to access, update, and delete the value without searching for it first. Heap order do not allow for <code>O(log m)</code> search (where <code>m</code> is the number of values currently stored inside the heap), just for <code>O(m)</code> search, so this feature allow for some performance gain if you need to manipulate values anywhere in the heap (not just on top of the heap). Besides access, which is <code>O(1)</code>, update and delete are <code>O(log m)</code> as they may need to rebalance the tree.</p><p>If the tracking system is not needed, there is little reason to use this heap.</p><p>I wrote this package because the MutableBinaryHeap of DataStructures.jl did not allow some behavior I wanted; behavior as:</p><ol><li>a non-top value can be deleted without being made top first;</li><li>values can be deleted and others inserted without double rebalancing;</li><li>after a value is deleted, its tracker can be re-reused to re-insert that value or insert a new value (but this is not done automatically);</li><li>the arity of the heap (binary, trinary, etc..) can be defined by the user (by parametric type) and inccur in minimal overhead.</li><li>all the stored values are in a Vector{V} in heap order, for easy backdoor/hacking access;</li><li>the integer type that is the tracker type can be defined by the user;</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L28-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.MaxHeapOrder" href="#TrackingHeaps.MaxHeapOrder"><code>TrackingHeaps.MaxHeapOrder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MaxHeapOrder</code></pre><p>The alternative type for the type parameter <code>O</code> (i.e., Order) of TrackingHeap. If used the heap will have the maximum value as top value.</p><p>See also: <a href="#TrackingHeaps.is_higher_than-Tuple{Type{MinHeapOrder},Any,Any}"><code>is_higher_than</code></a>, <a href="#TrackingHeaps.TrackingHeap"><code>TrackingHeap</code></a> </p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L108-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.MinHeapOrder" href="#TrackingHeaps.MinHeapOrder"><code>TrackingHeaps.MinHeapOrder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MinHeapOrder</code></pre><p>The default type for the type parameter <code>O</code> (i.e., Order) of TrackingHeap. If used the heap will have the minimum value as top value.</p><p>See also: <a href="#TrackingHeaps.is_higher_than-Tuple{Type{MinHeapOrder},Any,Any}"><code>is_higher_than</code></a>, <a href="#TrackingHeaps.TrackingHeap"><code>TrackingHeap</code></a> </p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L98-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.NoTrainingWheels" href="#TrackingHeaps.NoTrainingWheels"><code>TrackingHeaps.NoTrainingWheels</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NoTrainingWheels</code></pre><p>The alternative type for the type parameter <code>S</code> (i.e., Safety) of TrackingHeap. Inform the heap methods avoid any checking theoretically giving the best speed.</p><p>See also: <a href="#TrackingHeaps.SafeFromYourself"><code>SafeFromYourself</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L153-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.SafeFromYourself" href="#TrackingHeaps.SafeFromYourself"><code>TrackingHeaps.SafeFromYourself</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SafeFromYourself</code></pre><p>The default type for the type parameter <code>S</code> (i.e., Safety) of TrackingHeap. Inform the heap methods to use <code>@assert</code> to check for any possible inconsistencies, and throw KeyError tried to access/delete/update an non-existent key.</p><p>See also: <a href="#TrackingHeaps.NoTrainingWheels"><code>NoTrainingWheels</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L141-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.TrackingHeap" href="#TrackingHeaps.TrackingHeap"><code>TrackingHeaps.TrackingHeap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TrackingHeap{K, V, N, O, S} &lt;: AbstractDict{K, V}</code></pre><p>The type of a heap that has tracker/keys of type K (an integer), stored values of type V, that is N-ary (binary, trinary, etc...), with the order defined by O, and the safety level defined by S.</p><p>Equal values are allowed but, if more than one value could be the top value, then any of the equal values may be there (they can yet be distinguished by tracker).</p><p>The TrackingHeap implements (almost) all methods described in Dict interface, and can be seen as a Dict (with the special property of always allowing for fast access to the minimal/maximal value and its key). There is an AbstractHeap of DataStructures, but it was designed for heaps without key, and then an AbstractMutableHeap interface (for heaps with keys) was grafted into it. Also, inheriting such interface would make necessary that this package used DataStructures just for inheriting its abstract type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L163-L181">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.TrackingHeap-Union{Tuple{Type{V}}, Tuple{V}} where V" href="#TrackingHeaps.TrackingHeap-Union{Tuple{Type{V}}, Tuple{V}} where V"><code>TrackingHeaps.TrackingHeap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">TrackingHeap(tracking_heap) # copy constructor
TrackingHeap(::Type{V}; kwargs = ...)</code></pre><p>Constructs a TrackingHeap with default types for all type parameters except V (i.e., the stored values, that has no obvious default).</p><p>This constructor also accepts a variety of keyword arguments which allow to change the default type parameters and initialize the heap.</p><p>The constructor allow to initialize using: a values vector in heap order to be owned by the heap (no overhead, nor checking); a values iterable collection (the respective trackers should be assumed to be <code>one(K):convert(K, length(number of initial values))</code>); a pairs iterable collection. These options are mutually exclusive.</p><p>See also: <a href="#TrackingHeaps.MinHeapOrder"><code>MinHeapOrder</code></a>, <a href="#TrackingHeaps.SafeFromYourself"><code>SafeFromYourself</code></a></p><p><strong>Arguments</strong></p><ul><li><code>K</code>: The tracker keys type. Default: <code>typeof(length(T[]))</code>.</li><li><code>N</code>: The N-arity of the heap. Default: binary (i.e, 2).</li><li><code>O</code>: The ordering of the heap values. Default: MinHeapOrder.</li><li><code>S</code>: The safety level of the heap methods. Default: SafeFromYourself.</li><li><code>init_val_heap</code>: a Vector already in heap order. Default: empty.</li><li><code>init_val_coll</code>: an initial collections of values to be copied. Default: empty.</li><li><code>init_pairs</code>: an initial collection of pairs tracker-value to be copied. Default: empty.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L188-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.empty!!-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K" href="#TrackingHeaps.empty!!-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K"><code>TrackingHeaps.empty!!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">empty!!(heap) -&gt; heap</code></pre><p>Delete all stored values efficiently (consider internals structure unused). <code>O(1)</code>.</p><p>CAUTION: this resets which trackers are considered &quot;never used&quot;, so a call to <code>next_tracker</code> or <code>track!</code> after it will return the first tracker a newly created TrackingHeap gives (and so on).</p><p>Do not guarantee that previous <code>sizehint!</code> or any vector growth have their effect negated.</p><p>See also: <a href="#TrackingHeaps.extract!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>extract!</code></a>, <a href="#Base.delete!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>delete!</code></a> <a href="#TrackingHeaps.track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K"><code>track!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L749-L764">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.extract!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K" href="#TrackingHeaps.extract!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>TrackingHeaps.extract!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">extract!(heap, trck) -&gt; sval</code></pre><p>Delete the value referred by <code>trck</code> in the <code>heap</code>, and return it.</p><p>The <code>trck</code> can then be used to re-insert it, or to insert another value.</p><p>The heap may need to be rebalanced, so <code>O(log m)</code>.</p><p>See also: <a href="#Base.delete!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>delete!</code></a>, <a href="#Base.empty!-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K"><code>empty!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L519-L529">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.extract_and_push!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K,Pair{K,V}}} where S where O where N where V where K" href="#TrackingHeaps.extract_and_push!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K,Pair{K,V}}} where S where O where N where V where K"><code>TrackingHeaps.extract_and_push!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">extract_and_push!(heap, old_trck, new_trck =&gt; new_sval) -&gt; old_sval</code></pre><p>Similar to <code>extract_and_track!</code> but let you define <code>new_trck</code>.</p><p>CAUTION: guarantee that the value referred by old_trck will be extracted and the new pair will be pushed but does not guarantee that the internal heap structure will end up in the same state as calling <code>extract!</code> followed by <code>push!</code>.</p><p>See also: <a href="#TrackingHeaps.extract_and_track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K,V}} where S where O where N where V where K"><code>extract_and_track!</code></a>, <a href="#TrackingHeaps.extract!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>extract!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L561-L572">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.extract_and_track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K,V}} where S where O where N where V where K" href="#TrackingHeaps.extract_and_track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K,V}} where S where O where N where V where K"><code>TrackingHeaps.extract_and_track!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">extract_and_track!(heap, old_trck, new_sval) -&gt; (old_sval, new_trck)</code></pre><p>Similar to calling <code>extract!</code> followed by <code>track!</code> but more optimized.</p><p>CAUTION: guarantee that the value referred by old_trck will be extracted and the new value will be tracked but does not guarantee that the internal heap structure will end up in the same state as calling <code>extract!</code> followed by <code>track!</code>.</p><p>See also: <a href="#TrackingHeaps.pop_and_track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K"><code>pop_and_track!</code></a>, <a href="#TrackingHeaps.extract!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>extract!</code></a>, <a href="#TrackingHeaps.track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K"><code>track!</code></a>,</p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L595-L606">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.is_higher_than-Tuple{Type{MinHeapOrder},Any,Any}" href="#TrackingHeaps.is_higher_than-Tuple{Type{MinHeapOrder},Any,Any}"><code>TrackingHeaps.is_higher_than</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_higher_than(HeapOrderType, x, y) :: Bool</code></pre><p>To define an ordering that is not the stored value type (i.e., <code>V</code>) default, you can create a new empty type and extend the <code>is_higher_than</code> function with a method that takes such empty type and returns if <code>x</code> should be higher in the heap than <code>y</code> based on it (so you do not need to wrap the value type inside a new type for a different ordering).</p><p>Note that <code>is_higher_than</code> defaults to <code>&lt;</code> and <code>&gt;</code> instead of <code>isless</code> and <code>!isless</code> (that would be <code>&gt;=</code>).</p><p>Also, if you do not want to provide a <code>&lt;</code> and <code>&gt;</code> for the stored value type, you can instead just define this function for <code>::Type{MinHeapOrder}</code> (and/or <code>::Type{MaxHeapOrder}</code>) and <code>x</code>-and-<code>y</code> of the specific types of the values compared.</p><p>See also: <a href="#TrackingHeaps.MinHeapOrder"><code>MinHeapOrder</code></a>, <a href="#TrackingHeaps.MaxHeapOrder"><code>MaxHeapOrder</code></a>, <a href="#TrackingHeaps.TrackingHeap"><code>TrackingHeap</code></a> </p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L118-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.next_tracker-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K" href="#TrackingHeaps.next_tracker-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K"><code>TrackingHeaps.next_tracker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">next_tracker(heap) -&gt; trck</code></pre><p>Return the same tracker the next call of <code>track!</code> would return, without modifying the heap in any way. <code>O(1)</code>.</p><p>See also: <a href="#TrackingHeaps.track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K"><code>track!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L392-L399">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.pop_and_track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K" href="#TrackingHeaps.pop_and_track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K"><code>TrackingHeaps.pop_and_track!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pop_and_track!(heap, new_sval) -&gt; ((top_sval, top_trck), new_trck)</code></pre><p>Similar to calling <code>pop!</code> followed by <code>track!</code> but more optimized.</p><p>CAUTION: guarantee that the top will be popped and the new value will be tracked but does not guarantee that the internal heap structure will end up in the same state as calling <code>pop!</code> followed by <code>track!</code>.</p><p>See also: <a href="#Base.pop!-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K"><code>pop!</code></a>, <a href="#TrackingHeaps.track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K"><code>track!</code></a>,</p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L622-L632">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.pop_once_and_track_many!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},Any}} where S where O where N where V where K" href="#TrackingHeaps.pop_once_and_track_many!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},Any}} where S where O where N where V where K"><code>TrackingHeaps.pop_once_and_track_many!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pop_once_and_track_many!(heap, new_svals)::((top_sval,top_trck), new_trcks)</code></pre><p>Similar to calling <code>pop!</code> once followed by many calls to <code>track!</code> but more optimized.</p><p>CAUTION: guarantee that the top will be popped and the new values will be tracked but does not guarantee that the internal heap structure will end up in the same state as it would by calling <code>pop!</code> followed by calls to <code>track!</code> (in the same order given in the array).</p><p>See also: <a href="#Base.pop!-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K"><code>pop!</code></a>, <a href="#TrackingHeaps.track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K"><code>track!</code></a>, <a href="#TrackingHeaps.pop_and_track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K"><code>pop_and_track!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L645-L657">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.renew_tracker!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K" href="#TrackingHeaps.renew_tracker!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>TrackingHeaps.renew_tracker!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">renew_tracker!(heap, old_trck, new_trck = next_tracker(heap)) -&gt; new_trck</code></pre><p>Marks <code>old_trck</code> as unused, begins using <code>new_trck</code> to refer to the value previously pointed by <code>old_trck</code>, and returns new_trck.</p><p>Does not need any rebalancing, <code>O(1)</code>, but may inccur in memory allocation if <code>new_trck</code> was never used. The <code>new_trck</code> can be a tracker already used in the past, but must not be in use at the moment.</p><p>See also: <a href="#TrackingHeaps.pop_and_track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K"><code>pop_and_track!</code></a>, <a href="#TrackingHeaps.update!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K,V}} where S where O where N where V where K"><code>update!</code></a>, <a href="#TrackingHeaps.next_tracker-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K"><code>next_tracker</code></a>, <a href="#TrackingHeaps.extract_and_track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K,V}} where S where O where N where V where K"><code>extract_and_track!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L406-L418">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.top-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K" href="#TrackingHeaps.top-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K"><code>TrackingHeaps.top</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">top(heap) -&gt; (sval, trck)</code></pre><p>Returns the &quot;highest&quot; value stored inside the heap and its tracker. <code>O(1)</code>.</p><p>See also: <a href="#TrackingHeaps.is_higher_than-Tuple{Type{MinHeapOrder},Any,Any}"><code>is_higher_than</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L379-L385">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K" href="#TrackingHeaps.track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K"><code>TrackingHeaps.track!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">track!(heap, sval) -&gt; trck</code></pre><p>Insert a new sval into the heap and return a new &quot;never used&quot; tracker for it.</p><p>The return is the same the method <code>next_tracker</code> would give if called before <code>track!</code>. The heap may need to be rebalanced, so <code>O(log m)</code>.</p><p>See also: <a href="#TrackingHeaps.pop_and_track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K"><code>pop_and_track!</code></a>, <a href="#TrackingHeaps.next_tracker-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K"><code>next_tracker</code></a>, <a href="#TrackingHeaps.empty!!-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K"><code>empty!!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L457-L467">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.update!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K,V}} where S where O where N where V where K" href="#TrackingHeaps.update!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K,V}} where S where O where N where V where K"><code>TrackingHeaps.update!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">update!(heap, trck, new_value) -&gt; heap
update!(heap, trck =&gt; new_value) -&gt; heap</code></pre><p>Update the value pointed by <code>trck</code>. <code>O(log m)</code>.</p><p>Similar to <code>setindex!</code> but assumes <code>trck</code> exists, if it does not, gives a KeyError when <code>S === SafeFromYourself</code>, and undefined behaviour when <code>S !== SafeFromYourself</code>.</p><p>See also: <a href="#Base.setindex!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V,K}} where S where O where N where V where K"><code>setindex!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L484-L495">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K" href="#Base.delete!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">delete!(heap, trck) -&gt; heap</code></pre><p>Delete the value referred by <code>trck</code> in the <code>heap</code>, and return the <code>heap</code>.</p><p>The <code>trck</code> can then be used to re-insert it, or to insert another value.</p><p>The heap may need to be rebalanced, so <code>O(log m)</code>.</p><p>See also: <a href="#TrackingHeaps.extract!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>extract!</code></a>, <a href="#Base.pop!-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K"><code>pop!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L975-L985">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.empty!-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K" href="#Base.empty!-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K"><code>Base.empty!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">empty!(heap) -&gt; heap</code></pre><p>Delete all stored values efficiently (consider internals structure unused). <code>O(1)</code>.</p><p>CAUTION: this does not reset which trackers are considered &quot;never used&quot;, so a call to <code>next_tracker</code> before <code>empty!</code> and another after will return the same.</p><p>Do not guarantee that previous <code>sizehint!</code> or any vector growth have their effect negated.</p><p>See also: <a href="#TrackingHeaps.extract!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>extract!</code></a>, <a href="#Base.delete!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>delete!</code></a>, <a href="#TrackingHeaps.track!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V}} where S where O where N where V where K"><code>track!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L726-L740">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K" href="#Base.getindex-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getindex(heap, trck) -&gt; sval</code></pre><p>Return the value referred by <code>trck</code> in <code>heap</code>. O(1).</p><p>Only check if the tracker key exists if <code>S === SafeFromYourself</code>.</p><p>See also: <a href="#Base.setindex!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V,K}} where S where O where N where V where K"><code>setindex!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L798-L806">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{TrackingHeap}" href="#Base.isempty-Tuple{TrackingHeap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(heap) :: Bool</code></pre><p>Returns true if the heap has no values stored; false otherwise. <code>O(1)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L715-L719">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K" href="#Base.length-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">length(heap) :: K</code></pre><p>Returns the number of values currently stored inside the heap. <code>O(1)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L774-L778">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pop!-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K" href="#Base.pop!-Union{Tuple{TrackingHeap{K,V,N,O,S}}, Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}} where S where O where N where V where K"><code>Base.pop!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pop!(heap) -&gt; Pair(sval, trck)</code></pre><p>Delete the stored value at top of the heap, and return the <code>tracker =&gt; value</code>.</p><p>The <code>trck</code> can then be used to re-insert it, or to insert another value.</p><p>The heap may need to be rebalanced, so <code>O(log m)</code>.</p><p>See also: <a href="#TrackingHeaps.extract!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>extract!</code></a>, <a href="#Base.delete!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>delete!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L995-L1005">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setindex!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V,K}} where S where O where N where V where K" href="#Base.setindex!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},V,K}} where S where O where N where V where K"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setindex!(heap, new_value, trck) -&gt; heap</code></pre><p>Begin tracking new_value using trck if such tracker is not yet in use, update the value pointed by trck if such tracker was already in use.</p><p>Will rebalance the heap if necessary. <code>O(log m)</code>. Note: a vector with length equal to the highest used <code>trck</code> is kept, so giving <code>new_value</code> and arbitrarily large tracker can cause massive (and unnecessary) memory use.</p><p>See also: <a href="#TrackingHeaps.update!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K,V}} where S where O where N where V where K"><code>update!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L815-L826">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.last_child_ix-Union{Tuple{N}, Tuple{K}, Tuple{Val{N},K}} where N where K" href="#TrackingHeaps.last_child_ix-Union{Tuple{N}, Tuple{K}, Tuple{Val{N},K}} where N where K"><code>TrackingHeaps.last_child_ix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">last_child_ix</code></pre><p>Internal helper method. Do not use. Subject to change.</p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L262-L266">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.parent_ix-Union{Tuple{N}, Tuple{K}, Tuple{Val{N},K}} where N where K" href="#TrackingHeaps.parent_ix-Union{Tuple{N}, Tuple{K}, Tuple{Val{N},K}} where N where K"><code>TrackingHeaps.parent_ix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parent_ix</code></pre><p>Internal helper method. Do not use. Subject to change.</p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L250-L254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.sift!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K,V}} where S where O where N where V where K" href="#TrackingHeaps.sift!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K,V}} where S where O where N where V where K"><code>TrackingHeaps.sift!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sift!(heap, ix, previous_sval)</code></pre><p>Internal use. May be documented in the future. Avoid use unless strictly necessary.</p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L359-L364">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.sift_down!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K" href="#TrackingHeaps.sift_down!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>TrackingHeaps.sift_down!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sift_down!(heap, ix)</code></pre><p>Internal use. May be documented in the future. Avoid use unless strictly necessary.</p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L269-L274">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrackingHeaps.sift_up!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K" href="#TrackingHeaps.sift_up!-Union{Tuple{S}, Tuple{O}, Tuple{N}, Tuple{V}, Tuple{K}, Tuple{TrackingHeap{K,V,N,O,S},K}} where S where O where N where V where K"><code>TrackingHeaps.sift_up!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sift_up!(heap, ix)</code></pre><p>Internal use. May be documented in the future. Avoid use unless strictly necessary.</p></div></div><a class="source-link" target="_blank" href="https://github.com/henriquebecker91/TrackingHeaps.jl/blob/246f9c18f984c899c3caa32a007a5da7f55e9268/src/TrackingHeaps.jl#L321-L326">source</a></section><footer><hr/></footer></article></body></html>
